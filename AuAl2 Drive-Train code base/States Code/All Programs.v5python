{"mode":"Text","hardwareTarget":"brain","textContent":"'''\nThis the compiled codebase for all the programs that Los Colores (mahoraga V3) will be running\nat our Regional competition. All of the code that was ever produced for this robot can be found \nin our public GitHub repository: https://github.com/ThatParticularPencil/AuAl2-Code.\n\nAll of our programs were written fully in the Vex V5 Python implementation by hand. No external \nlibraries or programming environment were used (No PROSE or limlib).\n\nDuring competitions our autonomous programs are split between 5 different files. The files are\ncompletely identical except the unique autonomous pathing sections. Below, we have combined the\n5 files together by listing the autonomous programs one after another. You'll notice that the \nautonomous section has the same function defined 5 times: these are the 5 unique autons. We \ncant actually run it like this in competition, but we have added all 5 onto this file to save \nspace and maintain readability (otherwise we would have to print out all 5 600 line files that are \neach mostly identical :(  ).\n\nENJOY!\n'''\n\n\n\n#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code save\n# These are the special variables necessary for slew drive:\nMAX_DV = 96\nMAX_TV = 80\nTURN_SENS = .8\nalpha3 = 99\n\ncontroller_1 = Controller(PRIMARY)\nflex = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)           # This is the motor for our first stage intake. \nmotor_group_3_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nintake = MotorGroup(flex, motor_group_3_motor_b)                 # It's also in a motor group so that we can run both simultaneously\nMogo = DigitalOut(brain.three_wire_port.a)\ndoinker = DigitalOut(brain.three_wire_port.b)\nWall = Motor(Ports.PORT4, GearSetting.RATIO_18_1, False)\nL3 = Motor(Ports.PORT18, GearSetting.RATIO_6_1, True)            #Vex isnt naturally compatible with 6 motor drives\nR3 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)            #so we augmented the default code by adding these two motors\nleft_motor_a = Motor(Ports.PORT20, GearSetting.RATIO_6_1, True)\nleft_motor_b = Motor(Ports.PORT19, GearSetting.RATIO_6_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b,L3)\nright_motor_a = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nright_motor_b = Motor(Ports.PORT9, GearSetting.RATIO_6_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b,R3)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 299.24, 295, 40, MM, 0.75)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(100, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n#Necesary program for slew drive and PID:\ndef low_pass_filter(vprev, value, alpha):\n    return alpha*vprev +(1-alpha)*value\n\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n\n    ''' Below begins the implementation\n        for slew drive into the 6 motor drive code\n        first, the controller tracking variable is created with a neutral value'''\n    axis_3 = 0 \n\n\n    global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        global alpha3,TURN_SENS\n        #accel limiter by average:\n        axis_3 = low_pass_filter(axis_3, controller_1.axis3.position(), alpha3)\n\n        if remote_control_code_enabled:\n\n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis1\n            # right = axis3 - axis1\n            DL = axis_3+(controller_1.axis1.position()*TURN_SENS)\n            DR = axis_3-(controller_1.axis1.position()*TURN_SENS)\n\n            #limits the speeds of the drivetrains\n            drivetrain_left_side_speed = max(min(DL, MAX_DV),-MAX_DV)\n            drivetrain_right_side_speed = max(min(DR, MAX_DV),-MAX_DV)\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_1:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_1 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_1:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(5, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n#imports\nimport time\n#import threading dont need to import threads, they are automatic\nfrom math import sin,cos,tan,asin,acos,atan,pi,degrees,radians,sqrt\n\n# Begin project code\nwait(5,MSEC)\n\n################################\n#          Variables           #\n################################\n\nTeam = \"RED\" #either \"RED\" or \"BlUE\"\nTrackerRadius = 14.39/2 #bot radius\n\n#intaking specifics\nintake.set_velocity(90, PERCENT)\nintake.set_stopping(HOLD)\n\n#other subsystems\nIsDoinked = False\nWallPosition = 0\nhold_threshold = .3\nWall.set_stopping(HOLD)\n\n'''\nKp = 1.4 or .4\nKi = 0.4 or .03\nKd = 0.3 or .2\n''' \n\n\n\n################################\n#       CLASS DEFINITIONS      #\n################################\n\nHeading = 0 #first definition of the global\n\n\n'''manager is the class that handles the information that comes in from the\ncontroller and the robot and runs the functions to convert them to usable \nvalues'''\nclass Sensor_Manager:\n    global Heading\n    def __init__(self):\n        #self.IsUpdated = False\n        self.IMU1 =0\n        self.IMU2 = 0\n        self.TrackerF = 0\n        self.TrackerF2 = 0\n        #self.TrackerS = 0\n        #self.prevIMU1 = self.IMU1\n        #self.prevIMU2 = self.IMU2\n        self.prevTrackerF = self.TrackerF\n        #self.prevTrackerS = self.TrackerS\n        \n    #def get_IMU1(self):\n        #return imu1.heading(DEGREES)\n    #def get_IMU2(self):\n        #return imu2.heading(DEGREES)\n    def get_TrackerF(self):                 #the tracking wheels\n        return L3.position(DEGREES)* .0215\n    def get_TrackerF2(self):\n        return R3.position(DEGREES)* .0215\n    def get_TrackerS(self):\n        pass\n    def get_Heading(self,wWeight=1):\n        global Heading\n        num = degrees((self.TrackerF - self.TrackerF2)/(2*TrackerRadius))\n        Heading = num\n        return num \n\n    def update_Secondary(self):\n        #some loops\n        pass\n    def update(self):\n        Heading = self.get_Heading()\n        #self.prevIMU1 = self.IMU1\n        #self.prevIMU2 = self.IMU2\n        self.prevTrackerF = self.TrackerF\n        #self.prevTrackerS = self.TrackerS\n        #self.IMU1 = self.get_IMU1()\n        #self.IMU2 = self.get_IMU2()\n        self.TrackerF = self.get_TrackerF()\n        self.TrackerF2 = self.get_TrackerF2()\n        #self.TrackerS = self.get_TrackerS()    we dont have a sideways tracker\n        #self.IsUpdated = True\n\n\n'''The way our autonomous function works is that is creates a class object for each\nturn or movement. The controller is defined with its own target and variables and then \nit replaces itself  later.'''\n\nclass PID_Controller:\n    def __init__(self, Kp, Ki, Kd, target, alpha=0.2, umax=100, umin=.5):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.target = target\n        self.alpha = alpha  # Filtering coefficient for derivative term\n        self.umax = umax # integrator clamp max\n        self.umin = umin # integrator clamp min\n        \n        self.previous_error = 0     #all these are updated but start at zero\n        self.previous_derivative = 0\n        self.integral = 0\n        self.filtered_derivative = 0\n        self.prev_update = time.time()\n        \n    def update(self, Progress, dt):\n        error = self.target - Progress\n        print(error,\"error\")\n        \n        # Proportional term\n        P = self.Kp * error\n        # Derivative term (unfiltered)\n        if dt != 0:\n            D_unfiltered = (error - self.previous_error) / dt\n        else: \n            D_unfiltered = 1\n        \n        # Apply low-pass filter to the derivative term\n        self.filtered_derivative =low_pass_filter(self.previous_derivative, D_unfiltered, self.alpha)\n        p_d = self.filtered_derivative\n        #self.filtered_derivative = self.alpha * D_unfiltered + (1 - self.alpha) * self.filtered_derivative\n        D = self.Kd * self.filtered_derivative\n        \n        \n        # Clamped Integral term\n        dint_unclamped = error * dt\n        I_unclamped = self.Ki * dint_unclamped\n        if self.umin < abs(P + I_unclamped + D) < self.umax:\n            self.integral += dint_unclamped\n            I = I_unclamped\n        else: I = I_unclamped   \n\n        # Control output\n        U = P + I + D\n        if U > 30:\n            U = 30\n        elif U<-30:\n            U = -30\n        \n        # Update previous \n        self.previous_error = error\n        self.previous_derivative = p_d \n        print(U,\"U\")\n        return U\n\n\n\n################################\n#        FUNCS & INITS         #\n################################\nClampActive = False\n\n\n'''the auton select program draws colors on the brain that\nthat correspond to the alliance color we are on''' \ndef SelectAuton():\n    global Team\n    brain.screen.set_fill_color(Color.RED)\n    brain.screen.draw_rectangle(0, 0, 479, 239)\n    brain.screen.set_fill_color(Color.BLUE)\n    brain.screen.draw_rectangle(240, 0, 479, 239)\n\n    while brain.screen.pressing() == False:\n        if brain.screen.pressing():\n            break\n    \n    #after color is decided, it prints the team color \n    if brain.screen.x_position() >=240:\n        Team = \"Blue\"\n        brain.screen.clear_screen()\n        brain.screen.set_font(FontType.MONO60)\n        brain.screen.print(Team)\n    elif brain.screen.x_position() < 240:\n        brain.screen.clear_screen()\n        brain.screen.set_fill_color(Color.RED)\n        brain.screen.set_font(FontType.MONO60)\n        brain.screen.print(Team)\n    return Team\n\n#this code just shortens the intaking and outaking functions\ndef Intake():\n    intake.spin(FORWARD)\ndef Outtake():\n    intake.spin(REVERSE) \n\n\n''' This is the button logic for our short wall stake mech\nWe use the buttons y to set up and spin forward\nb to reset to loading position or reset to rest position\nx to mirror y and spin the arm backwards'''\n\ndef wallstake(pos = None):\n    global WallPosition\n    ratio = 4 #gear ratio\n    '''\n    rest =  0#the 4 marked positions for the arms maximums:\n    prime = 35\n    hold = 135\n    extend = 245'''\n\n    marks = [0,35,135,245,190,60] #list of arm positions\n    \n    if pos != None: # for auton\n        Wall.spin_to_position(marks[pos] *ratio ,DEGREES,wait=False)\n        WallPosition = marks[pos]\n\n    else: \n        if controller_1.buttonY.pressing(): #prime and spin forwards\n            if (Wall.position(DEGREES) / ratio) < marks[1]-10:\n                WallPosition = marks[1]\n            elif marks[1]-10 <= (Wall.position(DEGREES) / ratio) < marks[3]+10:\n                if Wall.position(DEGREES)/ratio > 160:\n                    WallPosition += .03\n                else:\n                    WallPosition += .06\n                if WallPosition >= marks[3]:\n                    WallPosition = marks[3]\n\n        if controller_1.buttonX.pressing(): #spin backwards\n            if Wall.position(DEGREES)/ratio > 160:\n                    WallPosition -= .03\n            else:\n                    WallPosition -= .06\n\n        if controller_1.buttonB.pressing(): #resets\n            if marks[1]+15 <= Wall.position(DEGREES)/ratio <= marks[3]+10:\n                WallPosition = marks[1]\n            elif Wall.position(DEGREES)/ratio <= marks[1]+15:\n                WallPosition = marks[0]\n\n        Wall.set_velocity((WallPosition - Wall.position(DEGREES)/ratio)*4)\n        Wall.spin(FORWARD)\n\n\n\n#subsystems\ndef clamp():\n    Mogo.set(True)\ndef release_clamp():\n    Mogo.set(False)\n\ndef doink():\n    global IsDoinked\n    IsDoinked = not IsDoinked\n    doinker.set(IsDoinked)\ndef release_doink():\n    doinker.set(False)\n\ndef buzz():\n    controller_1.rumble(\".\")\ncontroller_1.buttonL2.pressed(buzz())\n\n#Initializes the Sensor Manager\nManager = Sensor_Manager()\n#These are the functions for drive forward (head) and turn (circ)\ndef head(dist, P=1.8, I=0.4, D=0.7, deadzone = .3):\n    Control = PID_Controller(P, I, D, dist+Manager.TrackerF)\n    while True:\n        Manager.update()\n        drivetrain.set_drive_velocity(Control.update(Manager.TrackerF, time.time()-Control.prev_update), PERCENT)\n        if Control.target -deadzone < Manager.TrackerF < Control.target +deadzone and -4 < L3.velocity(PERCENT) < 4:\n            drivetrain.set_drive_velocity(0, PERCENT)\n            del Control\n            break\ndef circ(angl, P=.2 , I=.03, D=.5, deadzone = 1): #they are automatically filled with default pid constants\n    global Heading\n    if Team == \"Blue\":\n        angl *= -1\n    Control = PID_Controller(P, I, D, angl)\n    while True:\n        Manager.update()\n        drivetrain.set_turn_velocity(Control.update(Heading, time.time()-Control.prev_update), PERCENT)\n        if Control.target -deadzone < Heading < Control.target + deadzone and -3 < L3.velocity(PERCENT)< 3:\n            drivetrain.set_turn_velocity(0, PERCENT)\n            del Control\n            break\n\n\n################################\n#         CONTROL LOOP         #\n################################\ndrivetrain.set_drive_velocity(0,PERCENT)\nWall.set_velocity(100, PERCENT)\n\nTeam = SelectAuton()\nintake.set_velocity(100,PERCENT)\nintake.set_stopping(COAST)\n\ndef driver_control():\n    global alpha3, TURN_SENS\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    driving = True\n\n\n    print(\"driving\")\n    #buttons#\n    controller_1.buttonRight.pressed(doink)\n    while True: #this checks if we are triggering full nitro\n        #driving#\n        if controller_1.buttonL2.pressing():\n            alpha3 = .0\n            TURN_SENS = 1\n        else:\n            alpha3 = .98\n            TURN_SENS = .65\n\n        #subsystems#\n\n        if controller_1.buttonR1.pressing():\n            Intake()\n        elif controller_1.buttonR2.pressing():\n            Outtake()\n        else: intake.stop()\n\n        if controller_1.buttonL1.pressing():\n                release_clamp()\n        else:\n            clamp()\n\n        wallstake()\n        \n##################\n#AUTON PATHS     #\n##################\n\n'''\neach path starts out with a description, the default motor settings, and then the actual path\n'''\n\ndef autonomous(): #4 ring, 8 point auton, Negative Side\n    drivetrain.set_drive_velocity(0, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    \n    intake.set_velocity(100,PERCENT)\n    \n    drivetrain.set_stopping(HOLD)\n    drivetrain.drive(FORWARD)\n    drivetrain.turn(RIGHT)\n\n\n    ############################################################################\n\n    #alliance\n    wallstake(1)\n    wait(.3,SECONDS)\n    intake.spin(FORWARD)\n    wait(.3,SECONDS)\n    intake.stop()\n    wallstake(4)\n    wait(.8,SECONDS)\n    head(8)\n\n    #next\n    head(-8,2)\n    wallstake(0)\n    circ(15)\n    release_clamp()\n    intake.spin(REVERSE)\n    head(-38)\n    clamp()\n    wait(.1,SECONDS)\n\n    circ(140)\n    intake.spin(FORWARD)\n    head(17)\n    circ(133)\n    head(4)\n\n\n    head(-10)\n    circ(90)\n    head(15)\n    circ(108)\n    intake.stop()\n    wallstake(5)\n    head(-35,2)\n    \n\ndef autonomous():# Mobile goal rush, 2 ring auton, Positive Side\n    drivetrain.set_drive_velocity(0, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    \n    intake.set_velocity(100,PERCENT)\n    \n    drivetrain.set_stopping(HOLD)\n    drivetrain.drive(FORWARD)\n    drivetrain.turn(RIGHT)\n\n\n    ############################################################################\n\n    #Rush\n    flex.spin(FORWARD)\n    head(37,2.3,.4,.07,.7)\n    doink()\n    wait(.3,SECONDS)\n    flex.stop\n\n    #next goal\n    head(-20,1,.4,.07,.7)\n    release_doink()\n    wait(.4,SECONDS)\n    circ(112+20)\n    release_clamp()\n    head(-30)\n    clamp()\n    wait(.2,SECONDS)\n    circ(-30,.4)\n    wait(.2,SECONDS)\n    intake.spin(FORWARD)\n    wait(1,SECONDS)\n\n\n    #go to tower\n    wallstake(2)\n    intake.stop\n    head(12)\n    print(time.time)\n\ndef autonomous(): # 4 ring, 6 point auton, Negative Side\n    drivetrain.set_drive_velocity(0, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    \n    intake.set_velocity(100,PERCENT)\n    \n    drivetrain.set_stopping(HOLD)\n    drivetrain.drive(FORWARD)\n    drivetrain.turn(RIGHT)\n\n\n    ############################################################################\n\n    #Drive back 28 inches to clamp stake\n    head(-28, 1.6, .4, .3)\n\n    clamp()\n    wait(.5,SECONDS)\n    intake.spin(FORWARD)\n    wait(.2,SECONDS)\n\n    #turn towards first stack\n    circ(137)\n    #Drive 25 and intake\n    head(21, 1.6, .4, .3, .5)\n    head(-2,1.6,.4,.3,.5)\n    \n    #turn to second stack\n    circ(47)\n    #ring2\n    head(13, 2, .4, .3)\n    #ring3\n    circ(158)\n    head(10)\n\n    head(-10)\n    intake.stop()\n    circ(250,.4,0,.5)\n    head(25)\n\n\nautonomous(): #2 ring neutral sided auton\n    drivetrain.set_drive_velocity(0, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    \n    intake.set_velocity(100,PERCENT)\n    \n    drivetrain.set_stopping(HOLD)\n    drivetrain.drive(FORWARD)\n    drivetrain.turn(RIGHT)\n\n\n    ############################################################################\n\n    #Drive back 35 inches to clamp stake\n    head(-28, 1.6, .4, .3)\n\n    clamp()\n    wait(.5,SECONDS)\n    intake.spin(FORWARD)\n    wait(.2,SECONDS)\n\n    #turn towards first stack\n    circ(-90)\n    #Drive 25 and intake\n    head(24, 2, .4, .3, .5)\n    \n    intake.stop()\n    #turn to tower\n    circ(-220)\n    head(26)\n    wallstake(2)\n\n\ndef autonomous(): #skills autonomous programming, 21 points\n    drivetrain.set_drive_velocity(0, PERCENT)\n    drivetrain.set_turn_velocity(0, PERCENT)\n    \n    intake.set_velocity(100,PERCENT)\n    \n    drivetrain.set_stopping(HOLD)\n    drivetrain.drive(FORWARD)\n    drivetrain.turn(RIGHT)\n\n\n    ############################################################################\n\n    #Drive back 35 inches to clamp stake\n    wallstake(2)\n    wait(.5,SECONDS)\n    wallstake(1)\n    wait(.1,SECONDS)\n    wallstake(0)\n    head(-10)\n    circ(-90)\n    head(-17)\n    clamp()\n    wait(.5,SECONDS)\n\n    #2 rings\n    circ(90,.08)\n    intake.spin(FORWARD)\n    head(42,.4)\n    head(-5)\n    wait(1,SECONDS)\n    circ(205)\n    head(-10)\n    intake.spin_for(REVERSE,15,DEGREES)\n    release_clamp()\n    intake.stop()\n    wait(.1,SECONDS)\n\n    #second stake\n    head(10)\n    circ(93,.08,.04,.1)\n    head(-80,.5)\n    clamp()\n    wait(.5,SECONDS)\n    circ(-90)\n    \n    #2 rings\n    intake.spin(FORWARD)\n    head(30,.4)\n    head(-5)\n    circ(-215)\n    head(-10)\n    intake.spin_for(REVERSE,15,DEGREES)\n    release_clamp()\n    intake.stop()\n    wait(.1,SECONDS)\n    head(5)\n\n\ncompetition = Competition(driver_control, autonomous)\n\n\n","textLanguage":"python","robotConfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"split","id":"primary"},"triportSourcePort":22},{"port":[2],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1],"name":"Mogo","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"doinker","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"Wall","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[18],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20,19,10,9,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel325in","gear":"ratio6_1","gearRatio":"36:60","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null}],"slot":1,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}